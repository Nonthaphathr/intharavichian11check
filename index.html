<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏ó‡∏≤‡∏ô‡∏≠‡∏¥‡∏ô‡∏ó‡∏£‡∏ß‡∏¥‡πÄ‡∏ä‡∏µ‡∏¢‡∏£‡∏â‡∏±‡∏ô‡∏ó‡πå ‡πë‡πë V.1.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;500;600&family=Prompt:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Prompt', 'Sarabun', sans-serif; background-color: #f3f4f6; }
        .kru { background-color: #3b82f6; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; }
        .lahu { background-color: #ef4444; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; }
        .correct-mark { color: #22c55e; margin-left: 4px; }
        .error-mark { color: #ef4444; text-decoration: underline wavy #ef4444; }
        .syllable-box { display: inline-block; margin: 2px; text-align: center; }
        .rhyme-line { stroke: #f59e0b; stroke-width: 2; fill: none; }
    </style>
</head>
<body class="p-6">

    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-lg overflow-hidden">
        <div class="bg-blue-600 p-6 text-white text-center">
            <h1 class="text-2xl font-bold mb-2">‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏ó‡∏≤‡∏ô‡∏≠‡∏¥‡∏ô‡∏ó‡∏£‡∏ß‡∏¥‡πÄ‡∏ä‡∏µ‡∏¢‡∏£‡∏â‡∏±‡∏ô‡∏ó‡πå ‡πë‡πë</h1>
            <p class="text-blue-100">‡∏ß‡∏≤‡∏á‡∏ö‡∏ó‡∏õ‡∏£‡∏∞‡∏û‡∏±‡∏ô‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏°‡∏≤ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏â‡∏±‡∏ô‡∏ó‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡πÅ‡∏•‡∏∞‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™</p>
        </div>

        <div class="p-6">
            <div class="mb-6">
                <label class="block text-gray-700 text-sm font-bold mb-2">‡∏ß‡∏≤‡∏á‡∏ö‡∏ó‡∏õ‡∏£‡∏∞‡∏û‡∏±‡∏ô‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà (2 ‡∏ö‡∏ó):</label>
                <textarea id="poemInput" rows="5" class="shadow appearance-none border rounded w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:shadow-outline text-lg" placeholder="‡∏ß‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏°‡∏≤ ‡πÄ‡∏ä‡πà‡∏ô...&#10;‡∏ß‡∏¥‡∏ä‡∏≤‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ‡∏≠‡∏±‡∏ô‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÄ‡∏°‡∏∑‡∏≠‡∏á‡πÑ‡∏Å‡∏•&#10;‡∏ï‡πâ‡∏≠‡∏á‡∏¢‡∏≤‡∏Å‡∏•‡∏≥‡∏ö‡∏≤‡∏Å‡πÑ‡∏õ ‡∏à‡∏∂‡∏á‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏°‡∏≤"></textarea>
                <button onclick="analyzePoem()" class="mt-4 w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded transition duration-200 flex justify-center items-center gap-2">
                    <span>üîç ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á</span>
                </button>
            </div>

            <hr class="border-gray-200 my-6">

            <div id="resultArea" class="hidden">
                <h3 class="text-xl font-bold text-gray-800 mb-4 border-l-4 border-blue-500 pl-3">‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå</h3>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <div id="kruLahuScore" class="bg-gray-50 p-4 rounded-lg border"></div>
                    <div id="samphusScore" class="bg-gray-50 p-4 rounded-lg border"></div>
                </div>

                <div class="bg-slate-50 p-6 rounded-lg border border-slate-200">
                    <div id="visualResult" class="space-y-4 text-lg leading-loose font-medium text-gray-700"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. CORE LOGIC FROM YOUR ORIGINAL CODE ---
        // (‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏£‡∏∞, ‡∏ï‡∏±‡∏ß‡∏™‡∏∞‡∏Å‡∏î, ‡∏Ñ‡∏£‡∏∏-‡∏•‡∏´‡∏∏ ‡∏ó‡∏µ‡πà‡∏î‡∏∂‡∏á‡∏°‡∏≤‡∏à‡∏≤‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì)

        function getVowelAndFinalSound(word) {
            if (!word) return { vowel: '', finalGroup: '' };
            const cleanWord = word.replace(/[‡πà‡πâ‡πä‡πã‡πå]/g, '');
            const processedWord = processLeadingConsonants(cleanWord);

            // Ror Han Logic (Original)
            if (/‡∏£‡∏£[‡∏ñ‡∏ï‡∏©‡∏™‡∏®‡∏î‡∏à‡∏ä‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ó‡∏ò]$/.test(processedWord)) return { vowel: '‡∏≠‡∏∞', finalGroup: '‡∏Å‡∏î' };
            if (/‡∏£‡∏£[‡∏Ñ‡∏Å‡∏Ç‡∏Ü]$/.test(processedWord)) return { vowel: '‡∏≠‡∏∞', finalGroup: '‡∏Å‡∏Å' };
            if (/‡∏£‡∏£[‡∏û‡∏†‡∏ö‡∏õ‡∏ü]$/.test(processedWord)) return { vowel: '‡∏≠‡∏∞', finalGroup: '‡∏Å‡∏ö' };
            if (processedWord.endsWith('‡∏£‡∏£‡∏°')) return { vowel: '‡∏≠‡∏≥', finalGroup: '‡∏Å‡∏Å‡∏≤' };
            if (processedWord.endsWith('‡∏£‡∏£')) return { vowel: '‡∏≠‡∏∞', finalGroup: '‡∏Å‡∏ô' };
            if (processedWord.endsWith('‡∏£‡∏£‡∏ì')) return { vowel: '‡∏≠‡∏∞', finalGroup: '‡∏Å‡∏ô' };

            if (hasAiVowel(processedWord)) return { vowel: '‡πÑ‡∏≠', finalGroup: '‡πÄ‡∏Å‡∏¢' };

            const finalGroup = getFinalConsonantGroup(processedWord);
            const vowel = getVowelSound(processedWord);
            return { vowel, finalGroup };
        }

        function processLeadingConsonants(word) {
            const anamYWords = ['‡∏≠‡∏¢‡πà‡∏≤', '‡∏≠‡∏¢‡∏π‡πà', '‡∏≠‡∏¢‡πà‡∏≤‡∏á', '‡∏≠‡∏¢‡∏≤‡∏Å'];
            for (let anamWord of anamYWords) {
                if (word.startsWith(anamWord.replace(/[‡πà‡πâ‡πä‡πã‡πå]/g, ''))) return '‡∏¢' + word.substring(2);
            }
            if (word.length >= 2 && word.charAt(0) === '‡∏´') {
                const secondChar = word.charAt(1);
                if (['‡∏á', '‡∏¢', '‡∏ç', '‡∏£', '‡∏ô', '‡∏•', '‡∏°', '‡∏ß'].includes(secondChar)) return word.substring(1);
            }
            return word;
        }

        function hasAiVowel(word) {
            if (word.includes('‡πÑ') || word.includes('‡πÉ') || word.includes('‡∏±‡∏¢')) return true;
            const specialAiWords = ['‡∏ß‡∏±‡∏¢', '‡∏ä‡∏±‡∏¢', '‡∏†‡∏±‡∏¢', '‡πÑ‡∏ó‡∏¢', '‡∏≠‡∏±‡∏¢', '‡∏Ç‡∏±‡∏¢', '‡∏ô‡∏±‡∏¢', '‡∏•‡∏±‡∏¢', '‡∏™‡∏±‡∏¢', '‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢', '‡∏≠‡∏≤‡∏®‡∏±‡∏¢', '‡∏ß‡∏¥‡∏™‡∏±‡∏¢', '‡∏õ‡∏£‡∏ô‡∏±‡∏¢', '‡∏≠‡∏∏‡∏õ‡∏±‡∏¢', '‡∏ß‡∏¥‡∏ò‡∏±‡∏¢'];
            for (let specialWord of specialAiWords) {
                if (word === specialWord || word.endsWith(specialWord)) return true;
            }
            return false;
        }

        function getFinalConsonantGroup(word) {
            if (hasAiVowel(word)) return '‡πÄ‡∏Å‡∏¢';
            const lastChar = word.charAt(word.length - 1);
            const groups = {
                '‡∏Å‡∏Ç‡∏Ñ‡∏Ü': '‡∏Å‡∏Å', '‡∏à‡∏ä‡∏ã‡∏å‡∏ç‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏®‡∏©‡∏™‡∏é‡∏è‡∏ê‡∏ë‡∏í': '‡∏Å‡∏î', '‡∏ö‡∏õ‡∏û‡∏ü‡∏†': '‡∏Å‡∏ö',
                '‡∏ô‡∏ì‡∏£‡∏•‡∏¨': '‡∏Å‡∏ô', '‡∏°': '‡∏Å‡∏°', '‡∏á': '‡∏Å‡∏á', '‡∏¢': '‡πÄ‡∏Å‡∏¢', '‡∏ß': '‡πÄ‡∏Å‡∏≠‡∏ß'
            };
            for (let g in groups) {
                if (g.includes(lastChar)) return groups[g];
            }
            return '‡∏Å‡∏Å‡∏≤';
        }

        function getVowelSound(word) {
            // Simplified for brevity, prioritizing main logic
            if (hasAiVowel(word)) return '‡πÑ‡∏≠';
            if (word.includes('‡∏≠‡∏≥') || word.includes('‡∏≥')) return '‡∏≠‡∏≥';
            // ... (Includes shortened logic for other vowels if needed)
            
            // Check short vowels explicitly
            const shortVowels = ['‡∏∞', '‡∏¥', '‡∏∂', '‡∏∏', '‡πá', '‡∏±'];
            for(let v of shortVowels) {
                 if(word.includes(v)) return '‡∏≠‡∏∞'; // Treat as short sound group
            }
            return '‡∏≠‡∏≤'; // Default to long for simplicity in this context if not caught
        }

        function isLahu(word) {
            if (!word) return false;
            word = word.trim();
            const cleanWord = word.replace(/[‡πà‡πâ‡πä‡πã‡πå]/g, '');
            const processedWord = processLeadingConsonants(cleanWord);
            
            const specialLahu = ["‡∏Å‡πá", "‡∏ö‡πà", "‡∏ì", "‡∏ò"];
            if (specialLahu.includes(word)) return true;

            if (processedWord.includes("‡∏≠‡∏≥") || processedWord.includes("‡πÑ‡∏≠") || processedWord.includes("‡πÉ‡∏≠") || processedWord.includes("‡πÄ‡∏≠‡∏≤")) return false;
            if (hasEndingConsonant(word)) return false;

            // Short vowel check logic
            const forceKruLongVowels = ["‡∏≤", "‡∏µ", "‡∏∑", "‡∏π", "‡πÄ", "‡πÅ", "‡πÇ", "‡∏≠"];
            const shorteners = ["‡∏∞", "‡πá"];
            
            let hasLongVowel = false;
            for (let v of forceKruLongVowels) if (processedWord.includes(v)) hasLongVowel = true;

            if (hasLongVowel) {
                let isShortened = false;
                for (let s of shorteners) if (processedWord.includes(s)) isShortened = true;
                if (processedWord.includes("‡πÄ‡∏≠‡∏≤‡∏∞") || processedWord.includes("‡πÄ‡∏≠‡∏≠‡∏∞") || processedWord.includes("‡∏≠‡∏±‡∏ß‡∏∞") || processedWord.includes("‡πÄ‡∏≠‡∏µ‡∏¢‡∏∞")) isShortened = true;
                if (!isShortened) return false;
            }
            
            return true; // If passed all Kru checks, assume Lahu (simplified for validator)
        }

        function hasEndingConsonant(word) {
            const cleanWord = word.replace(/[‡πà‡πâ‡πä‡πã‡πå]/g, '');
            const processedWord = processLeadingConsonants(cleanWord);
            const finalConsonants = "‡∏Å‡∏Ç‡∏Ñ‡∏Ü‡∏à‡∏ä‡∏ã‡∏å‡∏ç‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏®‡∏©‡∏™‡∏é‡∏è‡∏ê‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏ô‡∏ì‡∏£‡∏•‡∏¨‡∏°‡∏¢‡∏ß‡∏á";
            const lastChar = processedWord.charAt(processedWord.length - 1);
            if (finalConsonants.includes(lastChar)) {
                if (processedWord.length === 1) return false;
                if ("‡πà‡πâ‡πä‡πã‡πå".includes(processedWord.charAt(processedWord.length - 2))) return false;
                return true;
            }
            return false;
        }

        function checkSamphus(word1, word2) {
            if (!word1 || !word2) return false;
            const sound1 = getVowelAndFinalSound(word1);
            const sound2 = getVowelAndFinalSound(word2);
            return sound1.vowel === sound2.vowel && sound1.finalGroup === sound2.finalGroup;
        }

        // --- 2. VALIDATOR LOGIC ---

        const PATTERN = [
            // Verse 1 (5 words)
            ['K', 'K', 'L', 'K', 'K'],
            // Verse 2 (6 words)
            ['L', 'L', 'K', 'L', 'K', 'K'],
            // Verse 3 (5 words)
            ['K', 'K', 'L', 'K', 'K'],
            // Verse 4 (6 words)
            ['L', 'L', 'K', 'L', 'K', 'K'],
            // Verse 5 (5 words) - Stanza 2
            ['K', 'K', 'L', 'K', 'K'],
            // Verse 6 (6 words)
            ['L', 'L', 'K', 'L', 'K', 'K'],
            // Verse 7 (5 words)
            ['K', 'K', 'L', 'K', 'K'],
            // Verse 8 (6 words)
            ['L', 'L', 'K', 'L', 'K', 'K']
        ];

        // Rhyme Map: [VerseIndex, WordIndex] (0-based)
        const RHYME_PAIRS = [
            { from: [0, 4], to: [1, 2], name: '‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ß‡∏£‡∏£‡∏Ñ (‡∏ö‡∏ó 1)' },
            { from: [1, 5], to: [2, 4], name: '‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ö‡∏≤‡∏ó (‡∏ö‡∏ó 1)' },
            { from: [3, 5], to: [5, 5], name: '‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ö‡∏ó' }, // Cross stanza
            { from: [4, 4], to: [5, 2], name: '‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ß‡∏£‡∏£‡∏Ñ (‡∏ö‡∏ó 2)' },
            { from: [5, 5], to: [6, 4], name: '‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ö‡∏≤‡∏ó (‡∏ö‡∏ó 2)' }
        ];

        function analyzePoem() {
            const input = document.getElementById('poemInput').value.trim();
            if(!input) return alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ß‡∏≤‡∏á‡∏ö‡∏ó‡∏õ‡∏£‡∏∞‡∏û‡∏±‡∏ô‡∏ò‡πå‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö");

            // 1. Split Text into Lines
            let lines = input.split(/\r?\n/).filter(line => line.trim() !== '');

            // 2. Segment Words (Using Browser's Intl.Segmenter)
            const segmenter = new Intl.Segmenter('th', { granularity: 'word' });
            let segmentedVerses = [];

            // Simple heuristic to grouping words into verses
            // Assume user enters line by line matching structure or continuous text
            // For robustness, we flatten all words and then chunks them according to pattern (5, 6, 5, 6...)
            let allWords = [];
            lines.forEach(line => {
                const iterator = segmenter.segment(line);
                for (let { segment, isWordLike } of iterator) {
                    if (isWordLike) allWords.push(segment.trim());
                }
            });

            // 3. Map Words to Pattern Structure
            let structuredPoem = [];
            let wordIndex = 0;
            let currentVerseWords = [];
            
            // Expected structure length
            const totalRequiredWords = 44; // (5+6+5+6) * 2

            if(allWords.length < totalRequiredWords) {
                alert(`‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≥‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏Ñ‡∏≥‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î (‡∏û‡∏ö ${allWords.length} ‡∏Ñ‡∏≥ ‡∏à‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ ${totalRequiredWords} ‡∏Ñ‡∏≥) ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ß‡πâ‡∏ô‡∏ß‡∏£‡∏£‡∏Ñ`);
            }

            for(let i=0; i < PATTERN.length; i++) {
                let requiredCount = PATTERN[i].length;
                let verseWords = [];
                for(let j=0; j < requiredCount; j++) {
                    if(wordIndex < allWords.length) {
                        verseWords.push(allWords[wordIndex]);
                        wordIndex++;
                    } else {
                        verseWords.push("?"); // Missing
                    }
                }
                structuredPoem.push(verseWords);
            }

            renderResult(structuredPoem);
        }

        function renderResult(poem) {
            const visualDiv = document.getElementById('visualResult');
            const resultArea = document.getElementById('resultArea');
            const kruLahuScore = document.getElementById('kruLahuScore');
            const samphusScore = document.getElementById('samphusScore');
            
            visualDiv.innerHTML = '';
            resultArea.classList.remove('hidden');

            let errorCount = 0;
            let samphusErrors = [];

            // 1. Render Syllables & Check Kru/Lahu
            poem.forEach((verse, vIndex) => {
                const verseDiv = document.createElement('div');
                verseDiv.className = "flex flex-wrap items-center gap-2 border-b border-gray-100 pb-2";
                
                // Add Verse Label
                const label = document.createElement('span');
                label.className = "text-xs text-gray-400 w-16";
                label.innerText = `‡∏ß‡∏£‡∏£‡∏Ñ ${vIndex + 1}`;
                verseDiv.appendChild(label);

                verse.forEach((word, wIndex) => {
                    const expected = PATTERN[vIndex][wIndex]; // 'K' or 'L'
                    const isLahuWord = isLahu(word);
                    const actual = isLahuWord ? 'L' : 'K';
                    
                    const span = document.createElement('span');
                    span.className = `syllable-box px-3 py-1 rounded relative ${actual === 'K' ? 'bg-blue-100 text-blue-800' : 'bg-red-100 text-red-800'}`;
                    
                    let statusIcon = '';
                    if(word === '?') {
                         span.className = "bg-gray-200 text-gray-500 px-3 py-1";
                         word = "[‡∏ß‡πà‡∏≤‡∏á]";
                    } else if (expected === actual) {
                        span.classList.add('border', expected === 'K' ? 'border-blue-300' : 'border-red-300');
                    } else {
                        span.classList.add('border-2', 'border-red-600', 'line-through', 'decoration-red-500');
                        statusIcon = `<span class="absolute -top-2 -right-2 bg-red-600 text-white text-[10px] px-1 rounded-full">‡πÅ‡∏Å‡πâ</span>`;
                        errorCount++;
                    }

                    span.innerHTML = `${word} <span class="text-[10px] opacity-50 block">${actual==='K'?'‡∏Ñ‡∏£‡∏∏':'‡∏•‡∏´‡∏∏'}</span>${statusIcon}`;
                    span.id = `w-${vIndex}-${wIndex}`; // Assign ID for line drawing later (if needed)
                    verseDiv.appendChild(span);
                });
                visualDiv.appendChild(verseDiv);
            });

            // 2. Check Samphus
            let samphusPass = 0;
            let samphusHTML = '<ul class="text-sm space-y-2">';
            
            RHYME_PAIRS.forEach(pair => {
                const w1 = poem[pair.from[0]]?.[pair.from[1]];
                const w2 = poem[pair.to[0]]?.[pair.to[1]];

                if(w1 && w2 && w1 !== '?' && w2 !== '?') {
                    const isRhyme = checkSamphus(w1, w2);
                    if(isRhyme) {
                        samphusPass++;
                        samphusHTML += `<li class="text-green-600">‚úÖ ${pair.name}: <b>${w1}</b> - <b>${w2}</b> (‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™)</li>`;
                    } else {
                        samphusHTML += `<li class="text-red-600">‚ùå ${pair.name}: <b>${w1}</b> - <b>${w2}</b> (‡πÑ‡∏°‡πà‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™)</li>`;
                        samphusErrors.push(pair.name);
                    }
                } else {
                    samphusHTML += `<li class="text-gray-400">‚ö™ ${pair.name}: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö</li>`;
                }
            });
            samphusHTML += '</ul>';

            // 3. Update Summary Boards
            kruLahuScore.innerHTML = `<h4 class="font-bold text-gray-700">‡∏ú‡∏±‡∏á‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö (‡∏Ñ‡∏£‡∏∏-‡∏•‡∏´‡∏∏)</h4>
                                      <p class="text-3xl font-bold ${errorCount === 0 ? 'text-green-500' : 'text-red-500'}">
                                        ${errorCount === 0 ? '‡∏ú‡πà‡∏≤‡∏ô‡∏â‡∏•‡∏∏‡∏¢!' : '‡∏û‡∏ö ' + errorCount + ' ‡∏à‡∏∏‡∏î‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç'}
                                      </p>`;
            
            samphusScore.innerHTML = `<h4 class="font-bold text-gray-700">‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö</h4>
                                      ${samphusHTML}`;

        }
    </script>
</body>
</html>
